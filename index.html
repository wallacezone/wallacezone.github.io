<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Family Tree Builder</title>
    <style>
        /* General body styling for a modern, clean look */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            color: #333;
        }

        /* Header styling */
        .header {
            background-color: #ffffff;
            padding: 10px 20px;
            border-bottom: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        h1 {
            margin: 0;
            font-size: 1.5em;
            color: #1c1e21;
        }

        /* Controls styling for import/export buttons */
        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            background-color: #1877f2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }

        .btn:hover {
            background-color: #166fe5;
        }

        /* Hide the default file input */
        input[type="file"] {
            display: none;
        }

        /* Main container for the SVG canvas */
        .tree-container {
            flex-grow: 1;
            width: 100%;
            height: 100%;
        }

        /* SVG styling */
        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        svg:active {
            cursor: grabbing;
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            visibility: hidden;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            transition: opacity 0.2s;
            opacity: 0;
        }

        /* Context menu for node actions */
        .context-menu {
            position: absolute;
            visibility: hidden;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 5px 0;
            min-width: 120px;
            z-index: 10;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
        }

        .context-menu-item:hover {
            background-color: #f0f2f5;
        }
    </style>
</head>
<body>

    <!-- Header Section -->
    <div class="header">
        <h1>Family Tree Builder <span id="version-indicator" style="font-size: 0.6em; color: #888; font-weight: normal;"></span></h1>
        <div class="controls">
            <button id="exportBtn" class="btn">Export Tree (JSON)</button>
            <label for="importFile" class="btn">Import Tree (JSON)</label>
            <input type="file" id="importFile" accept=".json">
        </div>
    </div>

    <!-- Main SVG Container -->
    <div class="tree-container">
        <svg id="tree-svg"></svg>
    </div>

    <!-- Tooltip Element -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Context Menu Element -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" id="addParent">Add Parent</div>
        <div class="context-menu-item" id="addChild">Add Child</div>
        <div class="context-menu-item" id="addPartner">Add Partner</div>
        <div class="context-menu-item" id="addSibling">Add Sibling</div>
        <hr style="margin: 5px 0; border: none; border-top: 1px solid #eee;">
        <div class="context-menu-item" id="editNode">Edit</div>
        <div class="context-menu-item" id="deleteNode">Delete</div>
    </div>


    <!-- D3.js Library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
        // --- DOM ELEMENT SELECTION ---
        const svg = d3.select("#tree-svg");
        const container = document.querySelector('.tree-container');
        const tooltip = d3.select("#tooltip");
        const contextMenu = d3.select("#contextMenu");
        const exportBtn = document.getElementById('exportBtn');
        const importFile = document.getElementById('importFile');

        // --- VERSION INDICATOR ---
        const version = "v2.5";
        document.getElementById('version-indicator').textContent = version;

        // --- INITIAL SETUP ---
        const width = container.clientWidth;
        const height = container.clientHeight;
        const nodeWidth = 140;
        const nodeHeight = 50;
        const horizontalSpacing = 40;
        const verticalSpacing = 70;


        let nodes = [];
        let links = [];
        let nodeIdCounter = 0;
        let selectedNode = null;

        // SVG containers for links and nodes
        const g = svg.append("g");
        let linkGroup = g.append("g").attr("class", "links");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");

        // --- ZOOM & PAN FUNCTIONALITY ---
        const zoom = d3.zoom().on("zoom", (event) => {
            g.attr("transform", event.transform);
        });
        svg.call(zoom);

        // --- CORE FUNCTIONS ---

        /**
         * Main update function to re-render the tree.
         */
        function update() {
            // 1. Calculate the layout
            updateLayout();

            // Node data join
            node = node.data(nodes, d => d.id)
                .join(
                    enter => {
                        const nodeGroup = enter.append("g")
                            .attr("class", "node")
                            .attr("transform", d => `translate(${d.x || width/2}, ${d.y || height/2})`) // Initial position before transition
                            .on("click", handleNodeClick)
                            .on("mouseover", handleMouseOver)
                            .on("mouseout", handleMouseOut);

                        nodeGroup.append("rect")
                            .attr("width", nodeWidth)
                            .attr("height", nodeHeight)
                            .attr("x", -nodeWidth / 2)
                            .attr("y", -nodeHeight / 2)
                            .attr("rx", 8)
                            .attr("ry", 8)
                            .attr("fill", "#fff")
                            .attr("stroke", "#999")
                            .attr("stroke-width", 2);

                        nodeGroup.append("text")
                            .attr("dy", ".35em")
                            .attr("text-anchor", "middle")
                            .style("pointer-events", "none")
                            .style("font-size", "14px")
                            .text(d => d.name);
                        
                        return nodeGroup;
                    },
                    update => update
                );
            
            node.select("text").text(d => d.name);
            node.transition().duration(500)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);

            // Link rendering
            renderLinks();
        }
        
        // --- LAYOUT CALCULATION ---
        function updateLayout() {
            if (nodes.length === 0) return;

            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            // Build relationship graph
            nodes.forEach(n => {
                n._parents = getParents(n, true);
                n._children = getChildren(n, true);
                n._partners = getPartners(n, true);
            });

            // --- DEPTH CALCULATION (VERTICAL POSITION) ---
            // A robust, iterative approach to correctly handle complex family structures.
            nodes.forEach(n => delete n.depth);
            let changedInLoop;
            do {
                changedInLoop = false;
                nodes.forEach(node => {
                    let currentDepth = node.depth;
                    let newDepth;

                    if (node._parents.length > 0) {
                        const parentDepths = node._parents.map(pId => nodeMap.get(pId).depth);
                        if (parentDepths.every(d => d !== undefined)) {
                            newDepth = Math.max(...parentDepths) + 1;
                        }
                    } else {
                        newDepth = 0; // Root node of a subtree
                    }

                    if (node._partners.length > 0) {
                        const partner = nodeMap.get(node._partners[0]);
                        if (partner && partner.depth !== undefined) {
                            newDepth = newDepth === undefined ? partner.depth : Math.max(newDepth, partner.depth);
                        }
                    }
                    
                    if (newDepth !== undefined && newDepth !== currentDepth) {
                        node.depth = newDepth;
                        changedInLoop = true;
                    }
                });
            } while (changedInLoop);

            // Assign depth 0 to any remaining disconnected nodes
            nodes.forEach(n => { if (n.depth === undefined) n.depth = 0; });
            const maxDepth = d3.max(nodes, n => n.depth) || 0;

            // Position nodes vertically by depth
            nodes.forEach(n => n.y = n.depth * (nodeHeight + verticalSpacing) + 50);

            // --- HORIZONTAL POSITIONING ---
            const levels = Array.from({ length: maxDepth + 1 }, () => []);
            nodes.forEach(n => levels[n.depth].push(n));
            
            // 1. Initial positioning
            levels.forEach(level => level.forEach((n, i) => { n.x = i * (nodeWidth + horizontalSpacing); }));

            // 2. Iteratively refine positions
            for (let iter = 0; iter < 5; iter++) {
                // Bottom-up pass: center parents over their children
                for (let i = maxDepth - 1; i >= 0; i--) {
                    levels[i].forEach(n => {
                        if (n._children.length > 0) {
                            const childrenNodes = n._children.map(cid => nodeMap.get(cid));
                            const meanX = d3.mean(childrenNodes, c => c.x);
                            if (meanX !== undefined) {
                                const partner = n._partners.length > 0 ? nodeMap.get(n._partners[0]) : null;
                                if (partner && partner.depth === i) {
                                    n.x = meanX - (nodeWidth + horizontalSpacing) / 2;
                                    partner.x = meanX + (nodeWidth + horizontalSpacing) / 2;
                                } else {
                                    n.x = meanX;
                                }
                            }
                        }
                    });
                }
                
                // Resolve overlaps within each level more gracefully
                levels.forEach(level => {
                    const sortedLevel = level.sort((a,b) => a.x - b.x);
                    for (let j = 0; j < sortedLevel.length - 1; j++) {
                        const node1 = sortedLevel[j];
                        const node2 = sortedLevel[j+1];
                        const gap = node2.x - node1.x;
                        const minGap = nodeWidth + horizontalSpacing;

                        if (gap < minGap) {
                            const shift = minGap - gap;
                            node2.x += shift; // Push the conflicting node
                        }
                    }
                });
            }

            // Center the whole tree
            if (nodes.length > 0) {
                const allX = nodes.map(n => n.x);
                const minX = d3.min(allX);
                const maxX = d3.max(allX);
                const treeWidth = maxX - minX;
                const shiftX = (width - treeWidth) / 2 - minX;
                nodes.forEach(n => n.x += shiftX);
            }
        }
        
        // --- LINK RENDERING ---
        function renderLinks() {
            linkGroup.selectAll("*").remove(); // Clear previous links

            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            const handledChildren = new Set();
            
            // Draw family hub links
            links.filter(l => l.type === 'partner').forEach(l => {
                const p1 = nodeMap.get(l.source);
                const p2 = nodeMap.get(l.target);
                if (!p1 || !p2) return;
                
                // Draw partner line
                linkGroup.append('path')
                    .attr('d', `M${p1.x},${p1.y} L${p2.x},${p2.y}`)
                    .attr('stroke', '#999').attr('stroke-width', 2);

                const children1 = getChildren(p1, true);
                const children2 = getChildren(p2, true);
                const commonChildren = children1.filter(c => children2.includes(c)).map(cid => nodeMap.get(cid)).filter(Boolean);

                if (commonChildren.length > 0) {
                    const parentMidX = (p1.x + p2.x) / 2;
                    const midY = p1.y + nodeHeight / 2 + verticalSpacing / 2;
                    
                    // Vertical line from parents' midpoint down to the connection level
                    linkGroup.append('path')
                         .attr('d', `M${parentMidX},${p1.y + nodeHeight/2} L${parentMidX},${midY}`)
                         .attr('fill', 'none')
                         .attr('stroke', '#999').attr('stroke-width', 2);

                    // Find the full horizontal extent needed for the connection bar
                    const allX = [parentMidX, ...commonChildren.map(c => c.x)];
                    const minX = d3.min(allX);
                    const maxX = d3.max(allX);

                    // The main horizontal bar
                    linkGroup.append('path')
                        .attr('d', `M${minX},${midY} L${maxX},${midY}`)
                        .attr('stroke', '#999').attr('stroke-width', 2);

                    // Lines from horizontal bar to each child
                    commonChildren.forEach(child => {
                        linkGroup.append('path')
                            .attr('d', `M${child.x},${midY} L${child.x},${child.y - nodeHeight/2}`)
                            .attr('stroke', '#999').attr('stroke-width', 2);
                        handledChildren.add(child.id);
                    });
                }
            });

            // Draw single-parent links
            links.filter(l => l.type === 'parent-child').forEach(l => {
                const child = nodeMap.get(l.target);
                if (!child || handledChildren.has(child.id)) return;

                const parent = nodeMap.get(l.source);
                if(!parent) return;
                
                linkGroup.append('path')
                    .attr('d', `M${parent.x},${parent.y + nodeHeight/2} L${child.x},${child.y - nodeHeight/2}`)
                    .attr('fill', 'none').attr('stroke', '#999').attr('stroke-width', 2);
            });
        }


        // --- DATA MANIPULATION ---
        // Does not call update() anymore. This is done by the action handlers.
        function addPerson(name, sourceNode = null, relationship = null) {
            const newNode = { id: nodeIdCounter++, name: name || "New Person", birth: "", death: "" };
            nodes.push(newNode);

            if (sourceNode && relationship) {
                if (relationship === 'child') {
                    links.push({ source: sourceNode.id, target: newNode.id, type: 'parent-child' });
                } else if (relationship === 'parent') {
                    links.push({ source: newNode.id, target: sourceNode.id, type: 'parent-child' });
                } else if (relationship === 'partner') {
                    links.push({ source: sourceNode.id, target: newNode.id, type: 'partner' });
                }
            }
            return newNode;
        }

        function deletePerson(nodeToDelete) {
            nodes = nodes.filter(d => d.id !== nodeToDelete.id);
            links = links.filter(l => l.source !== nodeToDelete.id && l.target !== nodeToDelete.id);
        }

        function editPerson(nodeToEdit) {
            const newName = prompt("Enter new name:", nodeToEdit.name);
            const newBirth = prompt("Enter birth date:", nodeToEdit.birth);
            const newDeath = prompt("Enter death date:", nodeToEdit.death);

            if (newName !== null) nodeToEdit.name = newName;
            if (newBirth !== null) nodeToEdit.birth = newBirth;
            if (newDeath !== null) nodeToEdit.death = newDeath;
        }

        // --- RELATIONSHIP HELPERS ---
        const getParents = (node, returnId = false) => {
            if(!node) return [];
            const parents = links.filter(l => l.target === node.id && l.type === 'parent-child').map(l => nodes.find(n => n.id === l.source)).filter(Boolean);
            return returnId ? parents.map(p => p.id) : parents;
        }
        const getChildren = (node, returnId = false) => {
            if(!node) return [];
            const children = links.filter(l => l.source === node.id && l.type === 'parent-child').map(l => nodes.find(n => n.id === l.target)).filter(Boolean);
            return returnId ? children.map(c => c.id) : children;
        }
        const getPartners = (node, returnId = false) => {
            if(!node) return [];
            const partners = links.filter(l => l.type === 'partner' && (l.source === node.id || l.target === node.id)).map(l => {
                const partnerId = l.source === node.id ? l.target : l.source;
                return nodes.find(n => n.id === partnerId);
            }).filter(Boolean);
            return returnId ? partners.map(p => p.id) : partners;
        }


        // --- EVENT HANDLERS ---
        function handleNodeClick(event, d) {
            event.stopPropagation();
            selectedNode = d;
            
            // Show/hide context menu items based on relationship limits
            d3.select('#addParent').style('display', getParents(d).length >= 2 ? 'none' : 'block');
            d3.select('#addPartner').style('display', getPartners(d).length >= 1 ? 'none' : 'block');

            contextMenu
                .style("visibility", "visible")
                .style("top", `${event.pageY}px`)
                .style("left", `${event.pageX}px`);
        }
        
        d3.select('body').on('click', () => contextMenu.style("visibility", "hidden"));

        function handleMouseOver(event, d) {
            tooltip
                .style("visibility", "visible").style("opacity", 1)
                .style("top", `${event.pageY - 10}px`).style("left", `${event.pageX + 10}px`)
                .html(`Born: ${d.birth || 'N/A'}<br>Died: ${d.death || 'N/A'}`);
        }

        function handleMouseOut() {
            tooltip.style("visibility", "hidden").style("opacity", 0);
        }

        // --- CONTEXT MENU ACTIONS ---
        // Each action now calls update() at the end to render the changes.
        document.getElementById('addParent').addEventListener('click', () => {
            if (!selectedNode || getParents(selectedNode).length >= 2) return;
            const name = prompt("Enter parent's name:");
            if (!name) return;

            const newParent = addPerson(name, selectedNode, 'parent');
            const existingParents = getParents(selectedNode).filter(p => p && p.id !== newParent.id);
            if(existingParents.length > 0) {
                 links.push({ source: newParent.id, target: existingParents[0].id, type: 'partner' });
            }
            update();
        });

        document.getElementById('addChild').addEventListener('click', () => {
            if (!selectedNode) return;
            const name = prompt("Enter child's name:");
            if(!name) return;

            const newChild = addPerson(name, selectedNode, 'child');
            const partners = getPartners(selectedNode);
            if (partners.length > 0) {
                 links.push({ source: partners[0].id, target: newChild.id, type: 'parent-child' });
            }
            update();
        });

        document.getElementById('addPartner').addEventListener('click', () => {
            if (!selectedNode || getPartners(selectedNode).length >= 1) return;
            const name = prompt("Enter partner's name:");
            if (!name) return;
            
            const newPartner = addPerson(name, selectedNode, 'partner');
            const children = getChildren(selectedNode);
            children.forEach(child => {
                const childParents = getParents(child);
                if (!childParents.some(p => p && p.id === newPartner.id)) {
                    links.push({ source: newPartner.id, target: child.id, type: 'parent-child' });
                }
            });
            update();
        });

        document.getElementById('addSibling').addEventListener('click', () => {
            if (!selectedNode) return;
            const name = prompt("Enter sibling's name:");
            if (!name) return;
            
            const newSibling = addPerson(name);
            const parents = getParents(selectedNode);
            parents.forEach(parent => {
                if (parent) {
                    links.push({ source: parent.id, target: newSibling.id, type: 'parent-child' });
                }
            });
            update();
        });

        document.getElementById('editNode').addEventListener('click', () => {
            if (selectedNode) {
                editPerson(selectedNode);
                update();
            }
        });
        
        document.getElementById('deleteNode').addEventListener('click', () => {
            if (selectedNode) {
                deletePerson(selectedNode);
                update();
            }
        });

        // --- IMPORT/EXPORT FUNCTIONALITY ---
        exportBtn.addEventListener('click', () => {
            const dataStr = JSON.stringify({ nodes, links, nodeIdCounter });
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url; a.download = 'family-tree.json';
            a.click(); a.remove(); URL.revokeObjectURL(url);
        });
        
        importFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.nodes && data.links) {
                        nodes = data.nodes; links = data.links;
                        nodeIdCounter = data.nodeIdCounter || (Math.max(...nodes.map(n => n.id)) + 1);
                        update();
                    } else { alert("Invalid JSON file format for family tree."); }
                } catch (error) { alert("Error parsing JSON file."); console.error(error); }
            };
            reader.readAsText(file);
            event.target.value = ''; 
        });

        // --- INITIALIZE THE APPLICATION ---
        function initialize() {
            if (nodes.length === 0) {
                const initialNode = { id: nodeIdCounter++, name: "You", birth: "", death: "" };
                nodes.push(initialNode);
            }
            update();
        }

        initialize();
    </script>
</body>
</html>

