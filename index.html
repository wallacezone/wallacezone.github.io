<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Family Tree Builder</title>
    <style>
        /* General body styling for a modern, clean look */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            color: #333;
        }

        /* Header styling */
        .header {
            background-color: #ffffff;
            padding: 10px 20px;
            border-bottom: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        h1 {
            margin: 0;
            font-size: 1.5em;
            color: #1c1e21;
        }

        /* Controls styling for import/export buttons */
        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            background-color: #1877f2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }

        .btn:hover {
            background-color: #166fe5;
        }

        /* Hide the default file input */
        input[type="file"] {
            display: none;
        }

        /* Main container for the SVG canvas */
        .tree-container {
            flex-grow: 1;
            width: 100%;
            height: 100%;
        }

        /* SVG styling */
        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        svg:active {
            cursor: grabbing;
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            visibility: hidden;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            transition: opacity 0.2s;
            opacity: 0;
        }

        /* Context menu for node actions */
        .context-menu {
            position: absolute;
            visibility: hidden;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 5px 0;
            min-width: 120px;
            z-index: 10;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
        }

        .context-menu-item:hover {
            background-color: #f0f2f5;
        }
    </style>
</head>
<body>

    <!-- Header Section -->
    <div class="header">
        <h1>Family Tree Builder <span id="version-indicator" style="font-size: 0.6em; color: #888; font-weight: normal;"></span></h1>
        <div class="controls">
            <button id="exportBtn" class="btn">Export Tree (JSON)</button>
            <label for="importFile" class="btn">Import Tree (JSON)</label>
            <input type="file" id="importFile" accept=".json">
        </div>
    </div>

    <!-- Main SVG Container -->
    <div class="tree-container">
        <svg id="tree-svg"></svg>
    </div>

    <!-- Tooltip Element -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Context Menu Element -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" id="addParent">Add Parent</div>
        <div class="context-menu-item" id="addChild">Add Child</div>
        <div class="context-menu-item" id="addPartner">Add Partner</div>
        <div class="context-menu-item" id="addSibling">Add Sibling</div>
        <hr style="margin: 5px 0; border: none; border-top: 1px solid #eee;">
        <div class="context-menu-item" id="editNode">Edit</div>
        <div class="context-menu-item" id="deleteNode">Delete</div>
    </div>


    <!-- D3.js Library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
        // --- DOM ELEMENT SELECTION ---
        const svg = d3.select("#tree-svg");
        const container = document.querySelector('.tree-container');
        const tooltip = d3.select("#tooltip");
        const contextMenu = d3.select("#contextMenu");
        const exportBtn = document.getElementById('exportBtn');
        const importFile = document.getElementById('importFile');

        // --- VERSION INDICATOR ---
        const version = "v2.2";
        document.getElementById('version-indicator').textContent = version;

        // --- INITIAL SETUP ---
        const width = container.clientWidth;
        const height = container.clientHeight;
        const nodeWidth = 140;
        const nodeHeight = 50;
        const horizontalSpacing = 40;
        const verticalSpacing = 70;


        let nodes = [];
        let links = [];
        let nodeIdCounter = 0;
        let selectedNode = null;

        // SVG containers for links and nodes
        const g = svg.append("g");
        let linkGroup = g.append("g").attr("class", "links");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");

        // --- ZOOM & PAN FUNCTIONALITY ---
        const zoom = d3.zoom().on("zoom", (event) => {
            g.attr("transform", event.transform);
        });
        svg.call(zoom);

        // --- CORE FUNCTIONS ---

        /**
         * Main update function to re-render the tree.
         */
        function update() {
            // 1. Calculate the layout
            updateLayout();

            // Node data join
            node = node.data(nodes, d => d.id)
                .join(
                    enter => {
                        const nodeGroup = enter.append("g")
                            .attr("class", "node")
                            .attr("transform", d => `translate(${d.x}, ${d.y})`)
                            .on("click", handleNodeClick)
                            .on("mouseover", handleMouseOver)
                            .on("mouseout", handleMouseOut);

                        nodeGroup.append("rect")
                            .attr("width", nodeWidth)
                            .attr("height", nodeHeight)
                            .attr("x", -nodeWidth / 2)
                            .attr("y", -nodeHeight / 2)
                            .attr("rx", 8)
                            .attr("ry", 8)
                            .attr("fill", "#fff")
                            .attr("stroke", "#999")
                            .attr("stroke-width", 2);

                        nodeGroup.append("text")
                            .attr("dy", ".35em")
                            .attr("text-anchor", "middle")
                            .style("pointer-events", "none")
                            .style("font-size", "14px")
                            .text(d => d.name);
                        
                        return nodeGroup;
                    },
                    update => update
                );
            
            node.select("text").text(d => d.name);
            node.transition().duration(500)
                .attr("transform", d => `translate(${d.x}, ${d.y})`);

            // Link rendering
            renderLinks();
        }
        
        // --- LAYOUT CALCULATION ---
        function updateLayout() {
            if (nodes.length === 0) return;

            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            // Build relationship graph
            nodes.forEach(n => {
                n._parents = getParents(n, true);
                n._children = getChildren(n, true);
                n._partners = getPartners(n, true);
                delete n.depth;
            });

            // Calculate depth (generation) for each node
            let maxDepth = 0;
            const depths = new Map();
            function getDepth(node) {
                if (depths.has(node.id)) return depths.get(node.id);
                if (node._parents.length === 0) {
                    depths.set(node.id, 0); return 0;
                }
                const parentDepths = node._parents.map(p => getDepth(nodeMap.get(p)));
                const depth = 1 + Math.max(...parentDepths);
                depths.set(node.id, depth);
                if (depth > maxDepth) maxDepth = depth;
                return depth;
            }
            nodes.forEach(n => n.depth = getDepth(n));

            // Position nodes vertically by depth
            nodes.forEach(n => n.y = n.depth * (nodeHeight + verticalSpacing) + 50);

            // Position nodes horizontally
            const levels = Array.from({ length: maxDepth + 1 }, () => []);
            nodes.forEach(n => levels[n.depth].push(n));
            
            // Position from bottom up
            for (let i = maxDepth; i >= 0; i--) {
                levels[i].forEach(n => {
                    if (n._children.length > 0) {
                        const childrenNodes = n._children.map(cid => nodeMap.get(cid));
                        n.x = d3.mean(childrenNodes, c => c.x);
                    }
                });
                
                // Group partners and position them together
                const positioned = new Set();
                levels[i].forEach(n => {
                    if (positioned.has(n.id)) return;
                    const partner = n._partners.length > 0 ? nodeMap.get(n._partners[0]) : null;
                    if (partner && partner.depth === i && !positioned.has(partner.id)) {
                        const avgChildX = d3.mean([...n._children, ...partner._children].map(cid => nodeMap.get(cid)), c => c.x);
                        const baseX = avgChildX || n.x || partner.x;
                        n.x = baseX - (nodeWidth + horizontalSpacing) / 2;
                        partner.x = baseX + (nodeWidth + horizontalSpacing) / 2;
                        positioned.add(n.id);
                        positioned.add(partner.id);
                    }
                });

                // Resolve overlaps
                const sortedLevel = levels[i].sort((a,b) => a.x - b.x);
                for (let j = 0; j < sortedLevel.length - 1; j++) {
                    const node1 = sortedLevel[j];
                    const node2 = sortedLevel[j+1];
                    const gap = node2.x - node1.x;
                    const minGap = nodeWidth + horizontalSpacing;
                    if (gap < minGap) {
                        const shift = (minGap - gap) / 2;
                        node1.x -= shift;
                        node2.x += shift;
                    }
                }
            }
        }
        
        // --- LINK RENDERING ---
        function renderLinks() {
            linkGroup.selectAll("*").remove(); // Clear previous links

            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            const handledChildren = new Set();
            
            // Draw family hub links
            links.filter(l => l.type === 'partner').forEach(l => {
                const p1 = nodeMap.get(l.source);
                const p2 = nodeMap.get(l.target);
                if (!p1 || !p2) return;
                
                // Draw partner line
                linkGroup.append('path')
                    .attr('d', `M${p1.x},${p1.y} L${p2.x},${p2.y}`)
                    .attr('stroke', '#999').attr('stroke-width', 2);

                const children1 = getChildren(p1, true);
                const children2 = getChildren(p2, true);
                const commonChildren = children1.filter(c => children2.includes(c)).map(cid => nodeMap.get(cid));

                if (commonChildren.length > 0) {
                    const midX = (p1.x + p2.x) / 2;
                    const midY = p1.y + nodeHeight / 2 + verticalSpacing / 2;
                    
                    // Vertical line from parents' midpoint
                    linkGroup.append('path')
                         .attr('d', `M${midX},${p1.y} L${midX},${midY}`)
                         .attr('stroke', '#999').attr('stroke-width', 2);
                    
                    // Horizontal line connecting children
                    const minChildX = d3.min(commonChildren, c => c.x);
                    const maxChildX = d3.max(commonChildren, c => c.x);
                    linkGroup.append('path')
                        .attr('d', `M${minChildX},${midY} L${maxChildX},${midY}`)
                        .attr('stroke', '#999').attr('stroke-width', 2);

                    // Lines from horizontal line to each child
                    commonChildren.forEach(child => {
                        linkGroup.append('path')
                            .attr('d', `M${child.x},${midY} L${child.x},${child.y - nodeHeight/2}`)
                            .attr('stroke', '#999').attr('stroke-width', 2);
                        handledChildren.add(child.id);
                    });
                }
            });

            // Draw single-parent links
            links.filter(l => l.type === 'parent-child').forEach(l => {
                const child = nodeMap.get(l.target);
                if (handledChildren.has(child.id)) return;

                const parent = nodeMap.get(l.source);
                linkGroup.append('path')
                    .attr('d', d3.linkVertical()({
                        source: [parent.x, parent.y],
                        target: [child.x, child.y]
                    }))
                    .attr('fill', 'none').attr('stroke', '#999').attr('stroke-width', 2);
            });
        }


        // --- DATA MANIPULATION ---
        function addPerson(name, sourceNode = null, relationship = null) {
            const newNode = { id: nodeIdCounter++, name: name || "New Person", birth: "", death: "" };
            nodes.push(newNode);

            if (sourceNode && relationship) {
                if (relationship === 'child') {
                    links.push({ source: sourceNode.id, target: newNode.id, type: 'parent-child' });
                } else if (relationship === 'parent') {
                    links.push({ source: newNode.id, target: sourceNode.id, type: 'parent-child' });
                } else if (relationship === 'partner') {
                    links.push({ source: sourceNode.id, target: newNode.id, type: 'partner' });
                }
            }
            update();
            return newNode;
        }

        function deletePerson(nodeToDelete) {
            nodes = nodes.filter(d => d.id !== nodeToDelete.id);
            links = links.filter(l => l.source !== nodeToDelete.id && l.target !== nodeToDelete.id);
            update();
        }

        function editPerson(nodeToEdit) {
            const newName = prompt("Enter new name:", nodeToEdit.name);
            const newBirth = prompt("Enter birth date:", nodeToEdit.birth);
            const newDeath = prompt("Enter death date:", nodeToEdit.death);

            if (newName !== null) nodeToEdit.name = newName;
            if (newBirth !== null) nodeToEdit.birth = newBirth;
            if (newDeath !== null) nodeToEdit.death = newDeath;
            
            update();
        }

        // --- RELATIONSHIP HELPERS ---
        const getParents = (node, returnId = false) => {
            const parents = links.filter(l => l.target === node.id && l.type === 'parent-child').map(l => nodes.find(n => n.id === l.source));
            return returnId ? parents.map(p => p.id) : parents;
        }
        const getChildren = (node, returnId = false) => {
            const children = links.filter(l => l.source === node.id && l.type === 'parent-child').map(l => nodes.find(n => n.id === l.target));
            return returnId ? children.map(c => c.id) : children;
        }
        const getPartners = (node, returnId = false) => {
            const partners = links.filter(l => l.type === 'partner' && (l.source === node.id || l.target === node.id)).map(l => nodes.find(n => n.id === (l.source === node.id ? l.target : l.source)));
            return returnId ? partners.map(p => p.id) : partners;
        }


        // --- EVENT HANDLERS ---
        function handleNodeClick(event, d) {
            event.stopPropagation();
            selectedNode = d;
            
            // Show/hide context menu items based on relationship limits
            d3.select('#addParent').style('display', getParents(d).length >= 2 ? 'none' : 'block');
            d3.select('#addPartner').style('display', getPartners(d).length >= 1 ? 'none' : 'block');

            contextMenu
                .style("visibility", "visible")
                .style("top", `${event.pageY}px`)
                .style("left", `${event.pageX}px`);
        }
        
        d3.select('body').on('click', () => contextMenu.style("visibility", "hidden"));

        function handleMouseOver(event, d) {
            tooltip
                .style("visibility", "visible").style("opacity", 1)
                .style("top", `${event.pageY - 10}px`).style("left", `${event.pageX + 10}px`)
                .html(`Born: ${d.birth || 'N/A'}<br>Died: ${d.death || 'N/A'}`);
        }

        function handleMouseOut() {
            tooltip.style("visibility", "hidden").style("opacity", 0);
        }

        // --- CONTEXT MENU ACTIONS ---
        document.getElementById('addParent').addEventListener('click', () => {
            if (!selectedNode || getParents(selectedNode).length >= 2) return;
            const name = prompt("Enter parent's name:");
            if (!name) return;

            const newParent = addPerson(name, selectedNode, 'parent');
            const existingParents = getParents(selectedNode).filter(p => p.id !== newParent.id);
            if(existingParents.length > 0) {
                 links.push({ source: newParent.id, target: existingParents[0].id, type: 'partner' });
            }
            update();
        });

        document.getElementById('addChild').addEventListener('click', () => {
            if (!selectedNode) return;
            const name = prompt("Enter child's name:");
            if (name) addPerson(name, selectedNode, 'child');
        });

        document.getElementById('addPartner').addEventListener('click', () => {
            if (!selectedNode || getPartners(selectedNode).length >= 1) return;
            const name = prompt("Enter partner's name:");
            if (!name) return;
            
            const newPartner = addPerson(name, selectedNode, 'partner');
            const children = getChildren(selectedNode);
            children.forEach(child => {
                const childParents = getParents(child);
                if (!childParents.some(p => p.id === newPartner.id)) {
                    links.push({ source: newPartner.id, target: child.id, type: 'parent-child' });
                }
            });
            update();
        });

        document.getElementById('addSibling').addEventListener('click', () => {
            if (!selectedNode) return;
            const name = prompt("Enter sibling's name:");
            if (!name) return;
            
            const newSibling = addPerson(name);
            const parents = getParents(selectedNode);
            parents.forEach(parent => {
                links.push({ source: parent.id, target: newSibling.id, type: 'parent-child' });
            });
            update();
        });

        document.getElementById('editNode').addEventListener('click', () => {
            if (selectedNode) editPerson(selectedNode);
        });
        
        document.getElementById('deleteNode').addEventListener('click', () => {
            if (selectedNode) deletePerson(selectedNode);
        });

        // --- IMPORT/EXPORT FUNCTIONALITY ---
        exportBtn.addEventListener('click', () => {
            const dataStr = JSON.stringify({ nodes, links, nodeIdCounter });
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url; a.download = 'family-tree.json';
            a.click(); a.remove(); URL.revokeObjectURL(url);
        });
        
        importFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.nodes && data.links) {
                        nodes = data.nodes; links = data.links;
                        nodeIdCounter = data.nodeIdCounter || (Math.max(...nodes.map(n => n.id)) + 1);
                        update();
                    } else { alert("Invalid JSON file format for family tree."); }
                } catch (error) { alert("Error parsing JSON file."); console.error(error); }
            };
            reader.readAsText(file);
            event.target.value = ''; 
        });

        // --- INITIALIZE THE APPLICATION ---
        function initialize() {
            if (nodes.length === 0) {
                const initialNode = { id: nodeIdCounter++, name: "You", birth: "", death: "" };
                nodes.push(initialNode);
            }
            update();
        }

        initialize();
    </script>
</body>
</html>

