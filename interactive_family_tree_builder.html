<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Family Tree Builder</title>
    <style>
        /* General body styling for a modern, clean look */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            color: #333;
        }

        /* Header styling */
        .header {
            background-color: #ffffff;
            padding: 10px 20px;
            border-bottom: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        h1 {
            margin: 0;
            font-size: 1.5em;
            color: #1c1e21;
        }

        /* Controls styling for import/export buttons */
        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            background-color: #1877f2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }

        .btn:hover {
            background-color: #166fe5;
        }

        /* Hide the default file input */
        input[type="file"] {
            display: none;
        }

        /* Main container for the SVG canvas */
        .tree-container {
            flex-grow: 1;
            width: 100%;
            height: 100%;
        }

        /* SVG styling */
        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        svg:active {
            cursor: grabbing;
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            visibility: hidden;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            transition: opacity 0.2s;
            opacity: 0;
        }

        /* Context menu for node actions */
        .context-menu {
            position: absolute;
            visibility: hidden;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 5px 0;
            min-width: 120px;
            z-index: 10;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
        }

        .context-menu-item:hover {
            background-color: #f0f2f5;
        }
    </style>
</head>
<body>

    <!-- Header Section -->
    <div class="header">
        <h1>Family Tree Builder</h1>
        <div class="controls">
            <button id="exportBtn" class="btn">Export Tree (JSON)</button>
            <label for="importFile" class="btn">Import Tree (JSON)</label>
            <input type="file" id="importFile" accept=".json">
        </div>
    </div>

    <!-- Main SVG Container -->
    <div class="tree-container">
        <svg id="tree-svg"></svg>
    </div>

    <!-- Tooltip Element -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Context Menu Element -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" id="addParent">Add Parent</div>
        <div class="context-menu-item" id="addChild">Add Child</div>
        <div class="context-menu-item" id="addPartner">Add Partner</div>
        <hr style="margin: 5px 0; border: none; border-top: 1px solid #eee;">
        <div class="context-menu-item" id="editNode">Edit</div>
        <div class="context-menu-item" id="deleteNode">Delete</div>
    </div>


    <!-- D3.js Library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
        // --- DOM ELEMENT SELECTION ---
        const svg = d3.select("#tree-svg");
        const container = document.querySelector('.tree-container');
        const tooltip = d3.select("#tooltip");
        const contextMenu = d3.select("#contextMenu");
        const exportBtn = document.getElementById('exportBtn');
        const importFile = document.getElementById('importFile');

        // --- INITIAL SETUP ---
        const width = container.clientWidth;
        const height = container.clientHeight;

        let nodes = [];
        let links = [];
        let nodeIdCounter = 0;
        let selectedNode = null;

        // --- D3 FORCE SIMULATION ---
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(120).strength(0.5))
            .force("charge", d3.forceManyBody().strength(-400))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("y", d3.forceY().strength(0.05)) // Adds a slight pull to the center vertically
            .on("tick", ticked);

        // SVG containers for links and nodes
        const g = svg.append("g");
        let link = g.append("g").attr("class", "links").selectAll(".link");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");

        // --- ZOOM & PAN FUNCTIONALITY ---
        const zoom = d3.zoom().on("zoom", (event) => {
            g.attr("transform", event.transform);
        });
        svg.call(zoom);


        // --- CORE FUNCTIONS ---

        /**
         * Main update function to re-render the tree.
         * This is called whenever the data (nodes or links) changes.
         */
        function update() {
            // Node data join
            node = node.data(nodes, d => d.id)
                .join(
                    enter => {
                        const nodeGroup = enter.append("g")
                            .attr("class", "node")
                            .call(drag(simulation))
                            .on("click", handleNodeClick)
                            .on("mouseover", handleMouseOver)
                            .on("mouseout", handleMouseOut);

                        nodeGroup.append("rect")
                            .attr("width", 140)
                            .attr("height", 50)
                            .attr("x", -70)
                            .attr("y", -25)
                            .attr("rx", 8)
                            .attr("ry", 8)
                            .attr("fill", "#fff")
                            .attr("stroke", "#999")
                            .attr("stroke-width", 2);

                        nodeGroup.append("text")
                            .attr("dy", ".35em")
                            .attr("text-anchor", "middle")
                            .style("pointer-events", "none")
                            .style("font-size", "14px")
                            .text(d => d.name);
                        
                        return nodeGroup;
                    }
                );
            
            // Update text for existing nodes that might have been edited
            node.select("text").text(d => d.name);

            // Link data join
            link = link.data(links, d => `${d.source.id}-${d.target.id}`)
                .join(
                    enter => enter.append("line")
                        .attr("class", "link")
                        .attr("stroke", "#999")
                        .attr("stroke-width", 2)
                );
            
            // Restart the simulation with new data
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }

        /**
         * Function called on each "tick" of the force simulation to update positions.
         */
        function ticked() {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
        }

        /**
         * Adds a new person to the tree.
         * @param {string} name - Name of the new person.
         * @param {object} sourceNode - The node to link the new person to. Can be null.
         * @param {string} relationship - Type of relationship ('parent', 'child', 'partner').
         */
        function addPerson(name, sourceNode = null, relationship = null) {
            const newNode = {
                id: nodeIdCounter++,
                name: name || "New Person",
                birth: "",
                death: "",
                x: sourceNode ? sourceNode.x : width / 2, // Start near source or center
                y: sourceNode ? sourceNode.y : height / 2,
            };
            nodes.push(newNode);

            if (sourceNode && relationship) {
                let source, target;
                if (relationship === 'child') {
                    source = sourceNode.id;
                    target = newNode.id;
                } else { // Parent or Partner
                    source = newNode.id;
                    target = sourceNode.id;
                }
                links.push({ source, target });
            }
            update();
        }

        /**
         * Deletes a node and its associated links.
         * @param {object} nodeToDelete - The node object to delete.
         */
        function deletePerson(nodeToDelete) {
            nodes = nodes.filter(d => d.id !== nodeToDelete.id);
            links = links.filter(l => l.source.id !== nodeToDelete.id && l.target.id !== nodeToDelete.id);
            update();
        }

        /**
         * Edits the details of an existing person.
         * @param {object} nodeToEdit - The node object to edit.
         */
        function editPerson(nodeToEdit) {
            const newName = prompt("Enter new name:", nodeToEdit.name);
            const newBirth = prompt("Enter birth date:", nodeToEdit.birth);
            const newDeath = prompt("Enter death date:", nodeToEdit.death);

            if (newName !== null) nodeToEdit.name = newName;
            if (newBirth !== null) nodeToEdit.birth = newBirth;
            if (newDeath !== null) nodeToEdit.death = newDeath;
            
            update();
        }


        // --- EVENT HANDLERS ---
        
        /**
         * Handles clicking on a node to show the context menu.
         */
        function handleNodeClick(event, d) {
            event.stopPropagation(); // Prevent SVG pan on node click
            selectedNode = d;
            contextMenu
                .style("visibility", "visible")
                .style("top", `${event.pageY}px`)
                .style("left", `${event.pageX}px`);
        }
        
        /**
         * Hides the context menu when clicking elsewhere.
         */
        d3.select('body').on('click', () => {
            contextMenu.style("visibility", "hidden");
            selectedNode = null;
        });

        /**
         * Handles mouseover on a node to show the tooltip.
         */
        function handleMouseOver(event, d) {
            tooltip
                .style("visibility", "visible")
                .style("opacity", 1)
                .style("top", `${event.pageY - 10}px`)
                .style("left", `${event.pageX + 10}px`)
                .html(`Born: ${d.birth || 'N/A'}<br>Died: ${d.death || 'N/A'}`);
        }

        /**
         * Handles mouseout on a node to hide the tooltip.
         */
        function handleMouseOut() {
            tooltip.style("visibility", "hidden").style("opacity", 0);
        }

        // Context Menu button handlers
        document.getElementById('addParent').addEventListener('click', () => {
            if (!selectedNode) return;
            const name = prompt("Enter parent's name:");
            if (name) addPerson(name, selectedNode, 'parent');
        });

        document.getElementById('addChild').addEventListener('click', () => {
            if (!selectedNode) return;
            const name = prompt("Enter child's name:");
            if (name) addPerson(name, selectedNode, 'child');
        });

        document.getElementById('addPartner').addEventListener('click', () => {
            if (!selectedNode) return;
            const name = prompt("Enter partner's name:");
            if (name) addPerson(name, selectedNode, 'partner');
        });

        document.getElementById('editNode').addEventListener('click', () => {
            if (selectedNode) editPerson(selectedNode);
        });
        
        document.getElementById('deleteNode').addEventListener('click', () => {
            if (selectedNode) deletePerson(selectedNode);
        });

        // --- DRAG FUNCTIONALITY ---
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        // --- IMPORT/EXPORT FUNCTIONALITY ---

        /**
         * Exports the current tree data to a JSON file.
         */
        exportBtn.addEventListener('click', () => {
            // We need to save links by ID, not by object reference
            const savableLinks = links.map(l => ({ source: l.source.id, target: l.target.id }));
            const dataStr = JSON.stringify({ nodes, links: savableLinks, nodeIdCounter });
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'family-tree.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
        
        /**
         * Imports tree data from a selected JSON file.
         */
        importFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.nodes && data.links) {
                        nodes = data.nodes;
                        links = data.links;
                        nodeIdCounter = data.nodeIdCounter || (Math.max(...nodes.map(n => n.id)) + 1);
                        update();
                    } else {
                        alert("Invalid JSON file format for family tree.");
                    }
                } catch (error) {
                    alert("Error parsing JSON file.");
                    console.error(error);
                }
            };
            reader.readAsText(file);
            // Reset input value to allow re-importing the same file
            event.target.value = ''; 
        });


        // --- INITIALIZE THE APPLICATION ---
        function initialize() {
            if (nodes.length === 0) {
                addPerson("You"); // Start with a single node
            }
            update();
        }

        initialize();

    </script>
</body>
</html>
